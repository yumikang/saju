generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  name          String?
  phone         String?
  avatarUrl     String?        @map("avatar_url")
  // Admin fields  
  role          Role           @default(USER)
  status        UserStatus     @default(ACTIVE)
  emailVerified Boolean        @default(false) @map("email_verified")
  lastLoginAt   DateTime?      @map("last_login_at") @db.Timestamptz(3)
  createdAt     DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt     DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)
  // Relations
  oauthAccounts UserOAuth[]
  favorites     Favorite[]
  namingResults NamingResult[]
  sajuData      SajuData[]
  sessions      UserSession[]
  auditLogs     AdminAuditLog[] @relation("Actor")
  profile       UserProfile?
  termsConsents TermsConsent[]
  payments      Payment[]
  serviceOrders ServiceOrder[]

  @@index([email])
  @@index([role])
  @@map("users")
}

model SajuData {
  id               String         @id @default(uuid())
  userId           String         @map("user_id")
  name             String
  birthDate        DateTime       @map("birth_date") @db.Date
  birthTime        String         @map("birth_time")
  isLunar          Boolean        @default(false) @map("is_lunar")
  gender           String
  yearGan          String         @map("year_gan")
  yearJi           String         @map("year_ji")
  monthGan         String         @map("month_gan")
  monthJi          String         @map("month_ji")
  dayGan           String         @map("day_gan")
  dayJi            String         @map("day_ji")
  hourGan          String         @map("hour_gan")
  hourJi           String         @map("hour_ji")
  woodCount        Int            @map("wood_count")
  fireCount        Int            @map("fire_count")
  earthCount       Int            @map("earth_count")
  metalCount       Int            @map("metal_count")
  waterCount       Int            @map("water_count")
  primaryYongsin   String?        @map("primary_yongsin")
  secondaryYongsin String?        @map("secondary_yongsin")
  createdAt        DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)
  namingResults    NamingResult[]
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("saju_data")
}

model NamingResult {
  id               String     @id @default(uuid())
  userId           String     @map("user_id")
  sajuDataId       String     @map("saju_data_id")
  lastName         String     @map("last_name")
  firstName        String     @map("first_name")
  fullName         String     @map("full_name")
  lastNameHanja    String?    @map("last_name_hanja")
  firstNameHanja   String?    @map("first_name_hanja")
  totalStrokes     Int        @map("total_strokes")
  balanceScore     Float      @map("balance_score")
  soundScore       Float      @map("sound_score")
  meaningScore     Float      @map("meaning_score")
  overallScore     Float      @map("overall_score")
  generationMethod String     @map("generation_method")
  aiModel          String?    @map("ai_model")
  aiPrompt         String?    @map("ai_prompt") @db.Text
  preferredValues  Json?      @map("preferred_values")
  notes            String?    @db.Text
  createdAt        DateTime   @default(now()) @map("created_at") @db.Timestamptz(3)
  favorites        Favorite[]
  sajuData         SajuData   @relation(fields: [sajuDataId], references: [id], onDelete: Cascade)
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sajuDataId])
  @@map("naming_results")
}

model Favorite {
  id             String       @id @default(uuid())
  userId         String       @map("user_id")
  namingResultId String       @map("naming_result_id")
  rating         Int?
  comment        String?      @db.Text
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz(3)
  namingResult   NamingResult @relation(fields: [namingResultId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, namingResultId])
  @@map("favorites")
}

model HanjaDict {
  id             String       @id @default(uuid())
  character      String       @unique
  meaning        String?
  strokes        Int?
  element        Element?
  yinYang        YinYang?     @map("yin_yang")
  review         ReviewStatus @default(ok)
  evidenceJSON   Json?        @map("evidence_json")
  decidedBy      String?      @map("decided_by")
  ruleset        String?
  codepoint      Int?
  koreanReading  String?      @map("korean_reading")
  chineseReading String?      @map("chinese_reading")
  radical        String?
  usageFrequency Int?         @default(0) @map("usage_frequency")
  nameFrequency  Int?         @default(0) @map("name_frequency")
  category       String?
  gender         String?
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt      DateTime     @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@index([element])
  @@index([strokes])
  @@index([usageFrequency], map: "usage_frequency_idx")
  @@map("hanja_dict")
}

model HanjaReading {
  id        Int      @id @default(autoincrement())
  character String
  reading   String
  soundElem Element? @map("sound_elem")
  isPrimary Boolean  @default(false) @map("is_primary")

  @@unique([character, reading])
  @@index([reading])
  @@map("hanja_reading")
}

model UserSession {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at") @db.Timestamptz(3)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("user_sessions")
}

enum Element {
  METAL @map("金")
  WOOD  @map("木")
  WATER @map("水")
  FIRE  @map("火")
  EARTH @map("土")
}

enum YinYang {
  YIN  @map("음")
  YANG @map("양")
}

enum ReviewStatus {
  ok
  needs_review
}

// Admin related enums
enum AuthProvider {
  GOOGLE @map("google")
  KAKAO  @map("kakao")
  NAVER  @map("naver")
}

enum Role {
  ADMIN    @map("admin")
  OPERATOR @map("operator")
  VIEWER   @map("viewer")
  USER     @map("user")
}

enum UserStatus {
  ACTIVE    @map("active")
  SUSPENDED @map("suspended")
}

// OAuth Account Linking
model UserOAuth {
  id             String       @id @default(uuid())
  userId         String       @map("user_id")
  provider       AuthProvider
  providerUserId String       @map("provider_user_id")
  email          String?
  emailVerified  Boolean      @default(false) @map("email_verified")
  name           String?
  profileImage   String?      @map("profile_image")
  profileRaw     Json?        @map("profile_raw") // Store complete profile from provider
  accessToken    String?      @map("access_token") @db.Text // Encrypted in production
  refreshToken   String?      @map("refresh_token") @db.Text // Encrypted in production
  expiresAt      DateTime?    @map("expires_at") @db.Timestamptz(3)
  linkedAt       DateTime     @default(now()) @map("linked_at") @db.Timestamptz(3)
  updatedAt      DateTime     @updatedAt @map("updated_at") @db.Timestamptz(3)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@index([userId])
  @@index([email])
  @@map("user_oauth")
}

// Admin Audit Log
model AdminAuditLog {
  id          String   @id @default(uuid())
  actorId     String   @map("actor_id")
  actor       User     @relation("Actor", fields: [actorId], references: [id])
  action      String   // e.g., "USER_SUSPEND", "JOB_RETRY", "HANJA_REVIEW_TOGGLE"
  targetType  String?  @map("target_type") // e.g., "User", "HanjaDict", "Job"
  targetId    String?  @map("target_id")
  beforeValue Json?    @map("before_value")
  afterValue  Json?    @map("after_value")
  metadata    Json?    // Additional context
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  @@index([actorId])
  @@index([action])
  @@index([targetType, targetId])
  @@index([createdAt])
  @@map("admin_audit_logs")
}

// User Profile - 사용자 추가 정보
model UserProfile {
  userId    String    @id @map("user_id")
  nickname  String?
  gender    Gender?
  birthDate DateTime? @map("birth_date") @db.Date
  phone     String?
  bio       String?   @db.Text
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_profiles")
}

// Terms Consent - 약관 동의 이력
model TermsConsent {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  version         String   // e.g., "2025-08-24"
  tosAgreed       Boolean  @map("tos_agreed")
  privacyAgreed   Boolean  @map("privacy_agreed")
  marketingAgreed Boolean  @default(false) @map("marketing_agreed")
  agreedAt        DateTime @default(now()) @map("agreed_at") @db.Timestamptz(3)
  revokedAt       DateTime? @map("revoked_at") @db.Timestamptz(3) // 동의 철회 시각
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, version])
  @@index([agreedAt])
  @@map("terms_consents")
}

// Gender enum
enum Gender {
  MALE   @map("M")
  FEMALE @map("F")
  OTHER  @map("X")
}

// Payment related enums
enum PaymentMethod {
  CARD           @map("card")
  BANK_TRANSFER  @map("bank_transfer")
  KAKAO_PAY      @map("kakao_pay")
  NAVER_PAY      @map("naver_pay")
  TOSS           @map("toss")
}

enum PaymentStatus {
  PENDING    @map("pending")
  COMPLETED  @map("completed")
  FAILED     @map("failed")
  REFUNDED   @map("refunded")
  CANCELLED  @map("cancelled")
}

enum Currency {
  KRW @map("KRW")
  USD @map("USD")
}

enum PaymentEventType {
  REQUESTED         @map("requested")
  APPROVED          @map("approved")
  FAILED            @map("failed")
  CANCELLED         @map("cancelled")
  REFUNDED          @map("refunded")
  WEBHOOK_RECEIVED  @map("webhook_received")
}

// Service related enums
enum ServiceType {
  NAMING              @map("naming")
  RENAMING            @map("renaming")
  SAJU_COMPATIBILITY  @map("saju_compatibility")
}

enum OrderStatus {
  PENDING      @map("pending")
  PAID         @map("paid")
  IN_PROGRESS  @map("in_progress")
  COMPLETED    @map("completed")
  CANCELLED    @map("cancelled")
}

// Payment model - 결제 정보
model Payment {
  id              String        @id @default(uuid())
  userId          String        @map("user_id")
  serviceOrderId  String        @unique @map("service_order_id")
  provider        String        // PG사: tosspayments, kakaopay, naverpay 등
  transactionId   String        @map("transaction_id") // 외부 결제 시스템 거래 ID (required for idempotency)
  method          PaymentMethod // 결제 수단
  status          PaymentStatus // 결제 상태
  amount          Int           // 결제 금액 (최소 단위: 원)
  currency        Currency      @default(KRW) // 통화
  paidAt          DateTime?     @map("paid_at") @db.Timestamptz(3) // 결제 완료 시각
  failedAt        DateTime?     @map("failed_at") @db.Timestamptz(3) // 결제 실패 시각
  refundedAt      DateTime?     @map("refunded_at") @db.Timestamptz(3) // 환불 시각
  cancelledAt     DateTime?     @map("cancelled_at") @db.Timestamptz(3) // 취소 시각
  metadata        Json?         // 추가 결제 정보 (PG사 응답, 에러 메시지 등)
  createdAt       DateTime      @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime      @updatedAt @map("updated_at") @db.Timestamptz(3)
  
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceOrder    ServiceOrder  @relation(fields: [serviceOrderId], references: [id], onDelete: Cascade)
  paymentEvents   PaymentEvent[]
  
  @@unique([provider, transactionId]) // 멱등성 보장 (중복 결제 방지)
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, status, createdAt(sort: Desc)])
  @@index([transactionId])
  @@map("payments")
}

// PaymentEvent model - 결제 이벤트 로그 (감사 추적)
model PaymentEvent {
  id            String            @id @default(uuid())
  paymentId     String            @map("payment_id")
  eventType     PaymentEventType  @map("event_type") // 이벤트 종류
  status        PaymentStatus?    // 이벤트 결과 상태
  amount        Int?              // 이벤트 관련 금액
  currency      Currency?         // 통화
  message       String?           // 이벤트 메시지
  metadata      Json?             // 추가 이벤트 데이터 (웹훅 응답 등)
  ipAddress     String?           @map("ip_address") // 요청 IP
  userAgent     String?           @map("user_agent") // 요청 User-Agent  
  createdAt     DateTime          @default(now()) @map("created_at") @db.Timestamptz(3)
  
  payment       Payment           @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  
  @@index([paymentId, createdAt(sort: Desc)])
  @@index([eventType])
  @@index([createdAt])
  @@map("payment_events")
}

// ServiceOrder model - 서비스 주문 정보
model ServiceOrder {
  id              String       @id @default(uuid())
  userId          String       @map("user_id")
  serviceType     ServiceType  @map("service_type") // 서비스 종류
  status          OrderStatus  // 주문 상태
  price           Int          // 서비스 가격 (원 단위)
  resultData      Json?        @map("result_data") // 서비스 결과 데이터
  completedAt     DateTime?    @map("completed_at") @db.Timestamptz(3) // 서비스 완료 시각
  createdAt       DateTime     @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime     @updatedAt @map("updated_at") @db.Timestamptz(3)
  
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  payment         Payment?     // 1:1 관계
  
  @@index([userId])
  @@index([serviceType])
  @@index([status])
  @@index([createdAt])
  @@map("service_orders")
}
